package main

import "fmt"

/**
指针函数，值传递与引用传递对比：
1、调用函数有两种方式传递参数：值传递和引用传递，或者叫做传值与传引用。
	a.传值：
		在调用函数时，将实际参数复制一份传递到函数中，这样在函数中对参数进行修改，将不会影响到原有内容数据。
		默认情况下，Go语言使用的是值传递，在调用过程中不会影响到原有内容的数据
		每次调用函数，都将实参复制一份再传递到函数中。每次都复制，性能会下降，Go语言中是使用指针和值传递配合的方式来避免性能降低的问题。
	b.传引用：
		传引用的方式是指在调用函数时，将实际参数的地址传递到函数中，那么在函数中对参数所做的修改，将影响原有的内容数据
		严格来说，Go语言是只有值传递，没有引用传递。因为传引用就是将参数的地址作为值来进行了传递。
		传引用的作用：
			1、传指针使得多个函数能操作同一个对象
			2、传指针更轻量级(8 bytes)，只需传内存地址。所以当传递大的结构体的时候，推荐使用指针。
*/

func main() {

	var a int = 10
	fmt.Printf("1. 变量a的内存地址：%p,值为：%v \n\n", &a, a)
	fmt.Printf("==================int 型变量a的内存地址：%p \n\n\n", &a) // 0xc0000160a8,10
	changeIntVal(a)
	fmt.Printf("2. changeIntVal函数调用之后：变量a的内存地址：%p，值：%v \n\n", &a, a) // 0xc0000160a8,10
	changeIntPtr(&a)
	fmt.Printf("3. changeIntPtr函数调用之后：变量a的内存地址：%p，值：%v \n\n", &a, a) // 0xc0000aa058,100 地址没变，值变了

	fmt.Println("通过观察1、2、3步骤可知: 传入a的值时，变量a的地址和数据都没有变化，但传入a地址时，a的数据内容发生改变")
}

func changeIntPtr(a *int) {
	fmt.Printf("------------changeIntPtr函数：值参数a的内存地址：%p，值为：%v \n", &a, a)
	*a = 100
}

func changeIntVal(a int) {
	fmt.Printf("------------changeIntVal函数：值参数a的内存地址：%p，值为：%v \n", &a, a) // 0xc0000160d0,10 内存地址变了
	a = 90
}
